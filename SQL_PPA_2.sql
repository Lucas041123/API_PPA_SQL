-- =============================================================================
-- SCRIPT_SQL_PPA_v2.sql
--
-- OBJETIVO:
-- 1. Agrupar procedures e functions existentes em Packages (PKG_USUARIO, PKG_FORUM).
-- 2. Adicionar um Package de utilidades (PKG_UTILIDADES) com SQL Dinâmico.
-- 3. Criar uma tabela de auditoria (AUDITORIA_USUARIOS).
-- 4. Criar uma Trigger (TRG_AUDITA_USUARIO_UPDATE) para popular a tabela de auditoria.
--
-- =============================================================================

-- -----------------------------------------------------------------------------
-- Etapa 1: Remover os objetos standalone antigos que serão "pacoteados"
-- -----------------------------------------------------------------------------

BEGIN
   EXECUTE IMMEDIATE 'DROP FUNCTION calcular_engajamento_usuario';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -4043 THEN RAISE; END IF; -- Ignora erro "objeto não existe"
END;
/

BEGIN
   EXECUTE IMMEDIATE 'DROP FUNCTION formatar_habilidades_usuario';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -4043 THEN RAISE; END IF;
END;
/

BEGIN
   EXECUTE IMMEDIATE 'DROP PROCEDURE gerar_relatorio_atividade_forum';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -4043 THEN RAISE; END IF;
END;
/

-- NOTA: A procedure 'registrar_novo_post' também será movida.
-- A API Java precisará de um pequeno ajuste (detalhado no final).
BEGIN
   EXECUTE IMMEDIATE 'DROP PROCEDURE registrar_novo_post';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -4043 THEN RAISE; END IF;
END;
/

-- -----------------------------------------------------------------------------
-- Etapa 2: Tabela de Auditoria (Requisito da Trigger)
-- -----------------------------------------------------------------------------
BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE auditoria_usuarios';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN RAISE; END IF; -- Ignora erro "tabela não existe"
END;
/

CREATE TABLE auditoria_usuarios (
    id             NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    usuario_id     NUMBER NOT NULL,
    data_mudanca   TIMESTAMP DEFAULT SYSTIMESTAMP,
    usuario_db     VARCHAR2(100) DEFAULT USER,
    campo_modificado VARCHAR2(100),
    valor_antigo   VARCHAR2(1000),
    valor_novo     VARCHAR2(1000)
);

COMMENT ON TABLE auditoria_usuarios IS
'Tabela para auditar mudanças sensíveis na tabela USUARIOS (ex: email, status).';

-- -----------------------------------------------------------------------------
-- Etapa 3: Especificações dos Packages
-- -----------------------------------------------------------------------------

-- Package para lógica de negócio relacionada a Usuários
CREATE OR REPLACE PACKAGE PKG_USUARIO AS

    /**
     * Calcula o "score de engajamento" de um usuário baseado no nº de posts.
     * @param p_usuario_id ID do usuário.
     * @return Número total de posts.
     */
    FUNCTION calcular_engajamento_usuario(
        p_usuario_id IN NUMBER
    ) RETURN NUMBER;

    /**
     * Formata as habilidades de um usuário em uma string única separada por vírgula.
     * @param p_usuario_id ID do usuário.
     * @return String formatada (ex: "Java, SQL, Docker").
     */
    FUNCTION formatar_habilidades_usuario(
        p_usuario_id IN NUMBER
    ) RETURN VARCHAR2;

END PKG_USUARIO;
/

-- Package para lógica de negócio relacionada a Fóruns e Posts
CREATE OR REPLACE PACKAGE PKG_FORUM AS

    /**
     * Procedure para gerar um relatório de atividade (impressão no console).
     * Usa CURSOR explícito.
     */
    PROCEDURE gerar_relatorio_atividade_forum;

    /**
     * Registra um novo post no banco de dados.
     * Esta procedure é chamada pela API Java.
     * @param p_titulo Título do post.
     * @param p_conteudo Conteúdo do post.
     * @param p_usuario_id ID do autor.
     * @param p_forum_id ID do fórum.
     * @param p_post_id_out Parâmetro de SAÍDA com o ID do novo post criado.
     */
    PROCEDURE registrar_novo_post (
        p_titulo      IN posts.titulo%TYPE,
        p_conteudo    IN posts.conteudo%TYPE,
        p_usuario_id  IN posts.usuario_id%TYPE,
        p_forum_id    IN posts.forum_id%TYPE,
        p_post_id_out OUT posts.id%TYPE
    );

END PKG_FORUM;
/

-- Package para rotinas genéricas e demonstração de SQL Dinâmico
CREATE OR REPLACE PACKAGE PKG_UTILIDADES AS

    /**
     * (DEMONSTRAÇÃO DE SQL DINÂMICO)
     * Conta o número de registros em qualquer tabela do schema.
     * Utiliza EXECUTE IMMEDIATE e DBMS_ASSERT para prevenir SQL Injection.
     * @param p_tabela_nome Nome da tabela (ex: 'USUARIOS', 'VAGAS').
     * @return Contagem de linhas.
     */
    FUNCTION contar_registros(
        p_tabela_nome IN VARCHAR2
    ) RETURN NUMBER;

END PKG_UTILIDADES;
/

-- -----------------------------------------------------------------------------
-- Etapa 4: Corpos (Implementação) dos Packages
-- -----------------------------------------------------------------------------

CREATE OR REPLACE PACKAGE BODY PKG_USUARIO AS

    FUNCTION calcular_engajamento_usuario(
        p_usuario_id IN NUMBER
    ) RETURN NUMBER IS
        v_total_posts NUMBER;
    BEGIN
        SELECT COUNT(*)
        INTO v_total_posts
        FROM posts
        WHERE usuario_id = p_usuario_id;

        RETURN v_total_posts;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN 0;
        WHEN OTHERS THEN
            RETURN -1;
    END;

    FUNCTION formatar_habilidades_usuario(
        p_usuario_id IN NUMBER
    ) RETURN VARCHAR2 IS
        v_lista_habilidades VARCHAR2(4000);
    BEGIN
        SELECT LISTAGG(habilidade, ', ') WITHIN GROUP (ORDER BY habilidade)
        INTO v_lista_habilidades
        FROM usuario_habilidades
        WHERE usuario_id = p_usuario_id;

        RETURN v_lista_habilidades;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN 'Nenhuma habilidade cadastrada';
        WHEN OTHERS THEN
            RETURN 'Erro ao buscar habilidades';
    END;

END PKG_USUARIO;
/

CREATE OR REPLACE PACKAGE BODY PKG_FORUM AS

    PROCEDURE gerar_relatorio_atividade_forum IS
        CURSOR c_forums IS
            SELECT id, nome FROM forums ORDER BY nome;

        v_total_posts NUMBER;
        v_forum_id forums.id%TYPE;
        v_forum_nome forums.nome%TYPE;
    BEGIN
        DBMS_OUTPUT.PUT_LINE('--- Relatorio de Atividade dos Foruns ---');
        DBMS_OUTPUT.PUT_LINE('-----------------------------------------');

        OPEN c_forums;
        LOOP
            FETCH c_forums INTO v_forum_id, v_forum_nome;
            EXIT WHEN c_forums%NOTFOUND;

            SELECT COUNT(*) INTO v_total_posts FROM posts WHERE forum_id = v_forum_id;

            DBMS_OUTPUT.PUT_LINE('Forum: ' || v_forum_nome || ' | Total de Posts: ' || v_total_posts);

        END LOOP;
        CLOSE c_forums;

        DBMS_OUTPUT.PUT_LINE('-----------------------------------------');
        DBMS_OUTPUT.PUT_LINE('Relatorio gerado com sucesso.');
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('Ocorreu um erro inesperado: ' || SQLERRM);
    END;

    PROCEDURE registrar_novo_post (
        p_titulo      IN posts.titulo%TYPE,
        p_conteudo    IN posts.conteudo%TYPE,
        p_usuario_id  IN posts.usuario_id%TYPE,
        p_forum_id    IN posts.forum_id%TYPE,
        p_post_id_out OUT posts.id%TYPE
    ) IS
    BEGIN
        INSERT INTO posts (titulo, conteudo, usuario_id, forum_id)
        VALUES (p_titulo, p_conteudo, p_usuario_id, p_forum_id)
        RETURNING id INTO p_post_id_out;

        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END;

END PKG_FORUM;
/

CREATE OR REPLACE PACKAGE BODY PKG_UTILIDADES AS

    FUNCTION contar_registros(
        p_tabela_nome IN VARCHAR2
    ) RETURN NUMBER IS
        v_sql_statement VARCHAR2(1000);
        v_count NUMBER;
        v_tabela_sanitizada VARCHAR2(128);
    BEGIN
        -- ** PREVENÇÃO DE SQL INJECTION **
        -- Garante que o nome da tabela é um nome SQL válido e simples,
        -- evitando que comandos maliciosos (ex: '; DROP TABLE ...') sejam injetados.
        v_tabela_sanitizada := DBMS_ASSERT.SIMPLE_SQL_NAME(p_tabela_nome);

        -- ** SQL DINÂMICO **
        -- Constrói a string de SQL
        v_sql_statement := 'SELECT COUNT(*) FROM ' || v_tabela_sanitizada;

        -- Executa a string de SQL dinamicamente
        EXECUTE IMMEDIATE v_sql_statement INTO v_count;

        RETURN v_count;
    EXCEPTION
        WHEN OTHERS THEN
            -- Captura erros (ex: tabela não existe)
            DBMS_OUTPUT.PUT_LINE('Erro ao contar registros: ' || SQLERRM);
            RETURN -1;
    END;

END PKG_UTILIDADES;
/

-- -----------------------------------------------------------------------------
-- Etapa 5: Trigger de Auditoria (Requisito da Trigger)
-- -----------------------------------------------------------------------------

CREATE OR REPLACE TRIGGER TRG_AUDITA_USUARIO_UPDATE
AFTER UPDATE ON usuarios
FOR EACH ROW
WHEN (
    OLD.email <> NEW.email OR
    OLD.ativo <> NEW.ativo
)
DECLARE
    v_campo VARCHAR2(100);
BEGIN
    -- Verifica se o email mudou
    IF :OLD.email <> :NEW.email THEN
        INSERT INTO auditoria_usuarios (usuario_id, campo_modificado, valor_antigo, valor_novo)
        VALUES (:OLD.id, 'EMAIL', :OLD.email, :NEW.email);
    END IF;

    -- Verifica se o status 'ativo' mudou
    IF :OLD.ativo <> :NEW.ativo THEN
        INSERT INTO auditoria_usuarios (usuario_id, campo_modificado, valor_antigo, valor_novo)
        VALUES (:OLD.id, 'ATIVO', TO_CHAR(:OLD.ativo), TO_CHAR(:NEW.ativo));
    END IF;

EXCEPTION
    WHEN OTHERS THEN
        -- Em um cenário real, logaríamos esse erro sem impedir a transação principal.
        NULL;
END;
/